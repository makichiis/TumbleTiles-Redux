from dataclasses import dataclass, field 
from typing import NamedTuple, Self 
from queue import Queue
from enum import Enum 
from abc import ABC 


# All comments are self-notes or TODOs and should be cleared or replaced with doc comments eventually 

# Structure of board:
# - Size (X width by Y height), row major (?)
# - Polyominoes (configurations of loose tiles joined by glues)
# - Concretes 

class Vec2D(NamedTuple):
    """A 2D position."""
    x: int 
    y: int 

    def add(self, other: Self):
        """Return the sum of this vector and `other`."""
        return Vec2D(x=self.x + other.x, y=self.y + other.y)


UNIT_VEC_NORTH: Vec2D = Vec2D(x=0, y=-1) 
UNIT_VEC_EAST: Vec2D = Vec2D(x=1, y=0)
UNIT_VEC_SOUTH: Vec2D = Vec2D(x=0, y=1)
UNIT_VEC_WEST: Vec2D = Vec2D(x=-1, y=0)


class GlueType(Enum):
    """A glue type, or no glue at all."""
    NONE = 0
    NORTH = 1
    EAST = 2
    SOUTH = 3
    WEST = 4


class GlueSides(NamedTuple):
    """A glue denotes a bond between two tiles. Tiles which are glue-bound never loose their relationship."""
    north: GlueType = GlueType.NONE 
    east: GlueType = GlueType.NONE 
    south: GlueType = GlueType.NONE 
    west: GlueType = GlueType.NONE 


@dataclass(frozen=False, slots=True) 
class Tile(ABC):
    """Base class for tiles."""
    pos: Vec2D 


def tile_uid_generator():
    uid = 1
    while True:
        yield uid 
        uid += 1

next_uid = tile_uid_generator() 

def get_next_uid() -> int:
    global next_uid 
    return next(next_uid)


@dataclass(frozen=False, slots=True) 
class Singleton(Tile):
    """
    A singleton is a tile whose position changes in tilt, and may attach itself
    to other singletons which share adjacent glues. 
    """

    uid: int = field(default_factory=get_next_uid)
    glues: GlueSides = field(default_factory=GlueSides)


@dataclass(frozen=False, slots=True) 
class Concrete(Tile):
    """ A concrete is a tile whose position will never change in simulation."""
    ...


# Not using polyomino nor concrete mesh types at the simulation level. They are only useful
# in specific optimizations involving the rendering of the board and certain algorithms.
# Will prefer and prioritize the use of caching patterns to separate optimization caches from
# the fundamental data.


@dataclass 
class Board:
    """A Board is a 2D space-bounded map which comprises of singleton and concrete tiles."""
    size: Vec2D 
    singletons: dict[Vec2D, Singleton] = field(default_factory=dict[Vec2D, Singleton]) 
    concretes: dict[Vec2D, Concrete] = field(default_factory=dict[Vec2D, Concrete]) 

    def change_tile_pos(self, tile: Tile, new_pos: Vec2D):
        """Update the position of a tile and update the internal tile index."""

        old_pos = tile.pos 
        tile.pos = new_pos 
        
        if type(tile) == Singleton:
            self.singletons.pop(old_pos)
            self.singletons[tile.pos] = tile 
        elif type(tile) == Concrete:
            self.concretes.pop(old_pos)
            self.concretes[tile.pos] = tile 


class TiltDirection(Enum):
    NORTH = 1 
    EAST = 2 
    SOUTH = 3 
    WEST = 4 


class TumbleController:
    """A utility driver which drives simulation of full tilt on a specified board."""
    @dataclass
    class Polyomino:
        """A set of tiles joined by a glues."""
        singletons: set[Singleton] = field(default_factory=set[Singleton])

    def __init__(self, board: Board):
        self.board = board 

        self.polyomino_cache: list[TumbleController.Polyomino] = [] # Lazily loaded 
        self.tiles_visited_cache: set[int] = set() # Reset every step 

    def get_polyomino(self, tile: Singleton) -> Polyomino:
        """Retrieve the effective polyomino generated by bonds between singleton tiles."""
        connected_tiles: set[Singleton] = set()

        tiles_to_visit: Queue[Singleton] = Queue()
        [tiles_to_visit.put(tile) for tile in self.glued_neighbors(tile)]

        while not tiles_to_visit.empty():
            tile = tiles_to_visit.get()
            if tile in connected_tiles: continue 

            [tiles_to_visit.put(neighbor) for neighbor in self.glued_neighbors(tile)]

        return TumbleController.Polyomino(connected_tiles)

    # TODO: Should I compute the entire polyomino instead? Probably yes. Or just cache the polyominoes. 
    def glued_neighbors(self, tile: Singleton) -> list[Singleton]:
        """Retrieve all neighbors adjacent to tile which share glues."""

        result: list[Singleton] = [] 

        pos_north = tile.pos.add(UNIT_VEC_NORTH)
        pos_east = tile.pos.add(UNIT_VEC_EAST)
        pos_south = tile.pos.add(UNIT_VEC_SOUTH)
        pos_west = tile.pos.add(UNIT_VEC_WEST)

        neighbor_north = None if not pos_north in self.board.singletons else self.board.singletons[pos_north]
        neighbor_east = None if not pos_east in self.board.singletons else self.board.singletons[pos_east]
        neighbor_south = None if not pos_south in self.board.singletons else self.board.singletons[pos_south]
        neighbor_west = None if not pos_west in self.board.singletons else self.board.singletons[pos_west]

        if neighbor_north and neighbor_north.glues.south == tile.glues.north:
            result.append(neighbor_north)
        
        if neighbor_east and neighbor_east.glues.west == tile.glues.east:
            result.append(neighbor_east)

        if neighbor_south and neighbor_south.glues.north == tile.glues.south:
            result.append(neighbor_south)

        if neighbor_west and neighbor_west.glues.east == tile.glues.west:
            result.append(neighbor_west)

        return result 

    def step_tiles_recursively(self, tile: Singleton, delta: Vec2D):
        """Step given tile and any glued or collided tiles."""

        # Terminate if this tile has been visited and (tried to be) moved
        if tile.uid in self.tiles_visited_cache:
            return 

        # Mark tile visited
        self.tiles_visited_cache.add(tile.uid)

        # Compute next position 
        projected_next_pos = tile.pos.add(delta)

        # Terminate if tile is touching concrete
        if projected_next_pos in self.board.concretes:
            return 

        # Step collided singleton tile if found, terminate if it does not move 
        if projected_next_pos in self.board.singletons:
            self.step_tiles_recursively(self.board.singletons[projected_next_pos], delta)
            if projected_next_pos in self.board.singletons: return 

        # for polyomino_sibling in self.glued_neighbors(tile):
        #     self.step_tiles_recursively(polyomino_sibling, delta)

        # merge polyominoes if possible

    def step(self, direction: TiltDirection):
        """Perform a single step of a full tilt sequence in a given direction."""

        delta = Vec2D(0, 0)

        match direction:
            case TiltDirection.NORTH:
                delta = UNIT_VEC_NORTH 
            case TiltDirection.EAST:
                delta = UNIT_VEC_EAST 
            case TiltDirection.SOUTH:
                delta = UNIT_VEC_SOUTH 
            case TiltDirection.WEST:
                delta = UNIT_VEC_WEST 

        for tile in self.board.singletons.values():
            self.step_tiles_recursively(tile, delta)

    def tumble(self, direction: TiltDirection):
        """Perform a complete full tilt in a given direction."""

        ...
