from board import Tile, Vec2D, TileMap, Board, Direction, Glue,\
    unit_vec, GlueMasks

from dataclasses import dataclass, field 
from queue import Queue 

# NOTE for developers: There are some guarantees we can make about polyominoes: 
# 
# 1. When a polyomino forms by a bonding of two glues, this bond will never
#    break. Thus, a polyomino may never *SHRINK* in size, though it may grow.
# 
# 2. During steps/tumbling, the movement of a polyomino is terminated by the 
#    first tile which cannot move further. Thus, only checking "delta edge"
#    tiles is necessary for testing collision, e.g., if a 2-column poly is
#    moving to the right, only tiles in the right column need be checked.
#
# Concretes
# 1. Concrete tiles do not need representation in memory as tile objects. Since
#    doing so is a waste of memory and time, I can simply store the concretes
#    as a list of locations which contain a concrete, then query that list when
#    perform relocation availability checking during tilt. 
# 2. When colliding with a concrete, it is possible to group a collection of
#    unbinded polyominoes as a single bounding box, to further minimize
#    recurses and bounds checking per-tile. 
# 
# Questions to ask once scalability becomes paramount:
# 1. How can additonal features be added without bloat? For instance, when
#    Factory Mode is introduced to this edition of TumbleTiles. 

class TumbleController:
    """Drives simulation of full or partial tilt on a specified board.
    
    Attributes
    ----------
    board : `Board` 
        The board that this simulation driver will access and permutate.

    glue_on_step : `bool`
        Specifies whether polyominoes will join by glues after each step, 
        rather than after full tilt. Configurable before each simulation call. 
    
    factory_mode : `bool` 
        Specifies whether polyominoes will be deleted when they reach the
        edge of a board.
    
    Simulation
    ----------
    This controller is the most basic construction of full/partial tilt simuation.
    The "edges" of a board -- that is, the bounding box represented by a board's
    size -- are treated as walls which halt movement of any polyomino which 
    collides perpendicularly with them. Concrete pixels are treated exactly as
    the edges of the board. 

    Tile stickiness is simulated, s.t. tiles with adjacent, matching glues are
    treated as polyominoes.  
    """
    @dataclass
    class Polyomino:
        """A set of tiles joined by a glues. Local cache of managed board tiles."""
        # TODO: Store redundant references to tiles on each delta edge to 
        #       minimize iteration time of polyominoes each step 
        tiles: TileMap = field(default_factory=TileMap)

    def __init__(self, board: Board, glue_on_step: bool=False, factory_mode: bool=False):
        self._board: Board = board 
        self.glue_on_step: bool = glue_on_step 
        self.factory_mode = factory_mode

        self._polyomino_cache: dict[Vec2D, TumbleController.Polyomino] = {} 
        self._effective_wall_cache: set[Vec2D] = set()  

    @property 
    def board(self) -> Board: return self._board 

    def get_polyomino(self, tile: Tile) -> Polyomino:
        """Retrieve the effective polyomino generated by bonds between tile tiles."""
        connected_tiles: dict[Vec2D, Tile] = {}

        tiles_to_visit: Queue[Tile] = Queue()
        tiles_to_visit.put(tile)

        while not tiles_to_visit.empty():
            tile = tiles_to_visit.get()
            if tile.position in connected_tiles: continue 

            connected_tiles[tile.position] = tile 

            [tiles_to_visit.put(neighbor) for neighbor in self.glued_neighbors(tile)]

        return TumbleController.Polyomino(TileMap(connected_tiles))

    # TODO: Should I compute the entire polyomino instead? Probably yes. Or just cache the polyominoes. 
    def glued_neighbors(self, tile: Tile) -> list[Tile]:
        """Retrieve all neighbors adjacent to `tile` which share glues."""

        if tile.glues == Glue.none:
            return [] 

        result: list[Tile] = [] 

        glue_north = tile.glues & GlueMasks.north 
        glue_east = tile.glues & GlueMasks.east 
        glue_south = tile.glues & GlueMasks.south 
        glue_west = tile.glues & GlueMasks.west 

        if glue_north:
            neighbor_north = self._board.tiles.elements.get(tile.position.add(unit_vec(Direction.north))) 
            if neighbor_north and (neighbor_north.glues & GlueMasks.south) == (glue_north >> 16):
                result.append(neighbor_north) 

        if glue_east:
            neighbor_east = self._board.tiles.elements.get(tile.position.add(unit_vec(Direction.east))) 
            if neighbor_east and (neighbor_east.glues & GlueMasks.west) == (glue_east >> 16):
                result.append(neighbor_east) 

        if glue_south:
            neighbor_south = self._board.tiles.elements.get(tile.position.add(unit_vec(Direction.south)))
            if neighbor_south and (neighbor_south.glues & GlueMasks.north) == (glue_south << 16):
                result.append(neighbor_south)

        if glue_west:
            neighbor_west = self._board.tiles.elements.get(tile.position.add(unit_vec(Direction.west)))
            if neighbor_west and (neighbor_west.glues & GlueMasks.east) == (glue_west << 16):
                result.append(neighbor_west) 

        return result 

    def position_is_available(self, at: Vec2D) -> bool:
        """Returns true if `pos` is within the bounding box of `self.board` and does not contain a concrete."""
        return (not (at in self._board.concretes or at in self._effective_wall_cache)) \
            and at.x >= 0 and at.y >= 0 \
            and at.x < self._board.size.x and at.y < self._board.size.y 

    def _get_adjacent_polyominoes(self, of: Polyomino, at_face: Vec2D) -> list[Polyomino]:
        """Retrieve all polyominoes in direction `at_face` which share a face with a given polyomino."""
        
        result: list[TumbleController.Polyomino] = [] 

        for pos in of.tiles.elements.keys():
            polyomino = self._polyomino_cache.get(pos.add(at_face))
            if polyomino == of: continue 
            if polyomino: result.append(polyomino)

        return result 

    def _refresh_wall_cache(self, for_direction: Direction):
        """Refreshes the cache of locations treated as walls when polyominoes cannot move."""
        self._effective_wall_cache.clear()

        # TODO: Use separate "movable polyomino" cache that is the difference of the wall cache and the poly cache

        delta = unit_vec(for_direction)
        polar_delta = Vec2D(-delta.x, -delta.y)

        queue: Queue[TumbleController.Polyomino] = Queue() # wall location queue

        # enqueue polyominoes adjacent to concretes and delta edge 
        for pos, polyomino in self._polyomino_cache.items():
            adjacent_pos = pos.add(delta)
            if not self.position_is_available(adjacent_pos):
                queue.put(polyomino)

        # deque wall locations and cache, enqueue
        while not queue.empty():
            polyomino = queue.get()

            for tile in polyomino.tiles:
                self._effective_wall_cache.add(tile.position)

            for adjacent_polyomino in self._get_adjacent_polyominoes(polyomino, polar_delta):
                if not next(iter(adjacent_polyomino.tiles.elements.keys())) in self._effective_wall_cache:
                    queue.put(adjacent_polyomino) 

    def _refresh_polyomino_cache(self):
        self._polyomino_cache.clear() 
    
        for tile in self._board.tiles.elements.values():
            polyomino = self.get_polyomino(tile)

            for tile in polyomino.tiles.elements.values():
                self._polyomino_cache[tile.position] = polyomino

    def _update_board(self):
        """
        Refresh the contents of the managed board to reflect changes made within this controller.
        """
        self._board.tiles.elements.clear() 
        for polyomino in self._polyomino_cache.values():
            self._board.tiles.elements.update(polyomino.tiles.elements)
            polyomino.tiles.elements.clear() 

    def _step_impl(self, direction: Direction): # TODO: Glue on step check 
        """Internal logic."""
        self._refresh_wall_cache(direction)

        delta = unit_vec(direction)

        # TODO: Tumble is broken (full tilt does not complete as expected) 

        for pos_initial, polyomino in self._polyomino_cache.items():
            mapped_position = next(iter(polyomino.tiles.elements.keys()))
            
            if mapped_position != pos_initial: continue 
            if mapped_position in self._effective_wall_cache: continue 

            for tile in polyomino.tiles.mut_iter():
                tile.position = tile.position.add(delta) 

        cache: dict[Vec2D, TumbleController.Polyomino] = {} 
        for polyomino in self._polyomino_cache.values():
            if next(iter(polyomino.tiles.elements.keys())) in cache: continue 

            for tile in polyomino.tiles:
                cache[tile.position] = polyomino 

        self._polyomino_cache = cache 

        # TODO: Polyomino cache invalidation (e.g., factory mode [?]) and merge glues 

    def step(self, direction: Direction): 
        """Perform a single step of a tilt in a given direction.
        
        Parameters
        ----------
        direction : `Direction`
            Cardinal direction with which to perform full tilt. 
        """
        self._refresh_polyomino_cache()
        self._step_impl(direction)
        self._update_board()

    def tumble(self, direction: Direction):
        """Perform a complete full tilt in a given direction.
        
        Parameters
        ----------
        direction : `Direction`
            Cardinal direction with which to perform full tilt. 
        """
        self._refresh_polyomino_cache()

        if direction == Direction.north or direction == Direction.south:
            for _ in range(self._board.size.y): 
                self._step_impl(direction) 
                if len(self._effective_wall_cache) == len(self.board.tiles): break 
        else:
            for _ in range(self._board.size.x): 
                self._step_impl(direction) 
                if len(self._effective_wall_cache) == len(self.board.tiles): break 
        
        self._update_board() 

    def run_sequence(self, of: list[Direction]):
        """Perform a sequence of full tilts with directiosn given by a list of movements.
        
        Parameters
        ----------
        of : `list[Direction]`
            Sequence of cardinal directions with which to perform a series of full tilts.
        """
        for direction in of: self.tumble(direction)

    def cycle(self, in_directions: list[Direction], n_times: int):
        """Repeat a sequence of full tilts 0 or more times.
        
        Parameters
        ----------
        in_directions : `list[Direction]`
            Sequence of cardinal directions with which to perform a series of full tilts.

        n_times : `int`
            Number of times to repeat a given sequence. 
        """
        for _ in range(n_times): self.run_sequence(in_directions)

